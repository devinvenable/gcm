#!/usr/bin/env bash
#
# gcm: A Git commit replacement tool that:
#   1. Collects the Git diff in the current directory (staged changes).
#   2. Searches for a .env file (up to 3 parent levels) containing API keys.
#   3. Calls Gemini API (preferred) or OpenAI API (fallback) to summarize the changes.
#   4. Commits the code with the generated summary.
#
# This version includes support for both Gemini and OpenAI APIs.

###############################################################################
# Utility function: Print error message to stderr and exit
###############################################################################
error_exit() {
  echo "[ERROR] $1" >&2
  exit 1
}

###############################################################################
# Step 1: Capture Git diff of staged changes
###############################################################################
diff_data=$(git diff --staged)
if [ -z "$diff_data" ]; then
  echo "No staged changes found. Please stage them with \`git add\` first."
  exit 1
fi

###############################################################################
# Step 2: Set or locate API keys
###############################################################################
# First check the environment variables
api_provider=""

# Try to find .env file containing API keys
env_file=""
search_dirs=("./" "../" "../../" "../../../" "../../../../../")
for dir in "${search_dirs[@]}"; do
  candidate="${dir}.env"
  if [[ -f "$candidate" ]]; then
    env_file="$candidate"
    break
  fi
done

# If not found yet, do a broader find (up to 3 levels).
if [[ -z "$env_file" ]]; then
  IFS=$'\n'
  for candidate in $(find ../../../ -maxdepth 3 -type f -name ".env" 2>/dev/null); do
    env_file="$candidate"
    break
  done
  unset IFS
fi

# Source the .env file if found
if [[ -n "$env_file" ]]; then
  echo "Loading API keys from $env_file"
  set -a
  # shellcheck source=/dev/null
  . "$env_file"
  set +a
fi

# Determine which API to use (prefer Gemini over OpenAI)
if [[ -n "$GEMINI_API_KEY" ]]; then
  api_provider="gemini"
  echo "Using Gemini API"
elif [[ -n "$OPENAI_API_KEY" ]]; then
  api_provider="openai"
  echo "Using OpenAI API (Gemini API key not found)"
else
  error_exit "Neither GEMINI_API_KEY nor OPENAI_API_KEY is defined in environment or in a .env file."
fi

###############################################################################
# Step 3: Create the prompt text
###############################################################################
# We'll store the entire diff plus instructions in a single variable, then
# pass it to `jq` or Python to safely encode it into JSON.

read -r -d '' prompt <<EOF
You are a helpful coding assistant. Please read the following Git diff and provide a concise summary of the changes suitable for a commit message. Also, list functions that were added or removed. On first line, do not use the word "summary" but instead use a single sentence that encapsulates or generalizes the entire commit. On subsequent lines you can go into more detail.

Diff:
$diff_data
EOF

###############################################################################
# Step 4: Safely convert 'prompt' into a JSON string
###############################################################################
# Option A: If you have jq installed, do:
if command -v jq >/dev/null 2>&1; then
  prompt_json=$(printf '%s' "$prompt" | jq -Rs .)
else
  # Option B: If jq is not available but Python is:
  # We read from stdin, load into Python string, and dump as JSON.
  prompt_json=$(python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))' <<< "$prompt")
fi

if [[ -z "$prompt_json" ]]; then
  error_exit "Failed to JSON-encode prompt (missing jq or Python?)."
fi

###############################################################################
# Step 5: Construct the JSON payload based on API provider
###############################################################################
if [[ "$api_provider" == "gemini" ]]; then
  json_payload=$(cat <<EOF
{
  "contents": [
    {
      "role": "user",
      "parts": [
        {
          "text": $prompt_json
        }
      ]
    }
  ],
  "generationConfig": {
    "temperature": 0.7
  }
}
EOF
)
else # openai
  json_payload=$(cat <<EOF
{
  "model": "gpt-3.5-turbo",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant specialized in writing concise commit messages."
    },
    {
      "role": "user", 
      "content": $prompt_json
    }
  ],
  "temperature": 0.7
}
EOF
)
fi

###############################################################################
# Step 6: Print debug info
###############################################################################
#echo "[DEBUG] JSON Payload to $api_provider API (below):"
#echo "----------------------------------------------------------------------"
#echo "$json_payload"
#echo "----------------------------------------------------------------------"

###############################################################################
# Step 7: Make the API request based on provider
###############################################################################
commit_summary=""
gemini_error=""
openai_error=""
api_success=false

if [[ "$api_provider" == "gemini" ]]; then
  # Try Gemini API first
  echo "Trying Gemini API..."
  gemini_response=$(curl -s \
    -H "Content-Type: application/json" \
    -d "$json_payload" \
    "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-001:generateContent?key=$GEMINI_API_KEY")
  
  # Check if Gemini response contains error
  if [[ $gemini_response == *"error"* ]]; then
    gemini_error=$(echo "$gemini_response" | grep -o '"message":"[^"]*"' | head -1 | sed 's/"message":"\(.*\)"/\1/g')
    echo "Gemini API error: $gemini_error"
    
    # Only fall back to OpenAI if OPENAI_API_KEY is available
    if [[ -n "$OPENAI_API_KEY" ]]; then
      echo "Falling back to OpenAI API..."
      # Construct OpenAI payload
      openai_payload=$(cat <<EOF
{
  "model": "gpt-3.5-turbo",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant specialized in writing concise commit messages."
    },
    {
      "role": "user", 
      "content": $prompt_json
    }
  ],
  "temperature": 0.7
}
EOF
)
      # Make OpenAI request
      openai_response=$(curl -s \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d "$openai_payload" \
        https://api.openai.com/v1/chat/completions)
      
      # Check if OpenAI response contains error
      if [[ $openai_response == *"error"* ]]; then
        openai_error=$(echo "$openai_response" | grep -o '"message":"[^"]*"' | head -1 | sed 's/"message":"\(.*\)"/\1/g')
        echo "OpenAI API error: $openai_error"
      else
        # Parse OpenAI response
        response=$openai_response
        if command -v jq >/dev/null 2>&1; then
          commit_summary=$(echo "$response" | jq -r '.choices[0].message.content // empty')
        else
          commit_summary=$(echo "$response" \
            | grep -o '"content":"[^"]*"' \
            | sed 's/"content":"\(.*\)"/\1/g')
        fi
        
        if [[ -n "$commit_summary" ]]; then
          api_success=true
        fi
      fi
    else
      echo "OpenAI API key is not available."
    fi
  else
    # Parse successful Gemini response
    response=$gemini_response
    if command -v jq >/dev/null 2>&1; then
      commit_summary=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty')
    else
      commit_summary=$(echo "$response" \
        | grep -o '"text":"[^"]*"' \
        | sed 's/"text":"\(.*\)"/\1/g')
    fi
    
    if [[ -n "$commit_summary" ]]; then
      api_success=true
    fi
  fi
else # openai as primary choice
  echo "Trying OpenAI API..."
  openai_response=$(curl -s \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -d "$json_payload" \
    https://api.openai.com/v1/chat/completions)
    
  # Check if OpenAI response contains error
  if [[ $openai_response == *"error"* ]]; then
    openai_error=$(echo "$openai_response" | grep -o '"message":"[^"]*"' | head -1 | sed 's/"message":"\(.*\)"/\1/g')
    echo "OpenAI API error: $openai_error"
    
    # Only fall back to Gemini if GEMINI_API_KEY is available
    if [[ -n "$GEMINI_API_KEY" ]]; then
      echo "Falling back to Gemini API..."
      gemini_response=$(curl -s \
        -H "Content-Type: application/json" \
        -d "$json_payload" \
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-001:generateContent?key=$GEMINI_API_KEY")
      
      # Check if Gemini response contains error
      if [[ $gemini_response == *"error"* ]]; then
        gemini_error=$(echo "$gemini_response" | grep -o '"message":"[^"]*"' | head -1 | sed 's/"message":"\(.*\)"/\1/g')
        echo "Gemini API error: $gemini_error"
      else
        # Parse successful Gemini response
        response=$gemini_response
        if command -v jq >/dev/null 2>&1; then
          commit_summary=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text // empty')
        else
          commit_summary=$(echo "$response" \
            | grep -o '"text":"[^"]*"' \
            | sed 's/"text":"\(.*\)"/\1/g')
        fi
        
        if [[ -n "$commit_summary" ]]; then
          api_success=true
        fi
      fi
    else
      echo "Gemini API key is not available."
    fi
  else
    # Parse OpenAI response
    response=$openai_response
    if command -v jq >/dev/null 2>&1; then
      commit_summary=$(echo "$response" | jq -r '.choices[0].message.content // empty')
    else
      commit_summary=$(echo "$response" \
        | grep -o '"content":"[^"]*"' \
        | sed 's/"content":"\(.*\)"/\1/g')
    fi
    
    if [[ -n "$commit_summary" ]]; then
      api_success=true
    fi
  fi
fi

# Handle case where both APIs failed
if [[ "$api_success" == "false" ]]; then
  echo "Both APIs failed to generate a commit message."
  echo "Gemini error: $gemini_error"
  echo "OpenAI error: $openai_error"
  
  # Ask user if they want to continue with a manual commit message
  echo "Do you want to enter a commit message manually? (y/n)"
  read -r user_choice
  
  if [[ "$user_choice" == "y" || "$user_choice" == "Y" ]]; then
    echo "Enter your commit message:"
    read -r commit_summary
    
    if [[ -z "$commit_summary" ]]; then
      error_exit "No commit message provided."
    fi
  else
    error_exit "Aborting commit due to API failures."
  fi
fi

###############################################################################
# Step 9: Commit with the generated summary
###############################################################################
echo "Committing with message: $commit_summary"
git commit -m "$commit_summary"
